var margin = {top:30, right:30, bottom:30, left:30},
	width = 450 - margin.right - margin.left,
	height = 450 - margin.top - margin.bottom

var svg = d3.select("#heatmap")
	.append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
	.append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

//var myGroups = I





// Convenience for acessing each personid index in the @data Object list
function mapify(dataset) {

	var mapping = new Map()
	for(const [i,data] of dataset.entries())
		mapping.set(data.personid, i)

	return mapping

}

var skipAttributes = ["personid", "KindredID", "suicide", "sex", "Age"]
d3.csv("q3.csv", function(data) { 
	
	let indexOf = mapify(data)
	let person = indexOf.get(String(47434)) // given an individual

	let personAttributes = {}
	let idx = 0
	Object.keys(data[person]).forEach(key => {

		if(skipAttributes.includes(key)) return	
		personAttributes[key] = data[person][key]

	})


	// Computing number of equal attributes between @person and @neighbors
	var closest_neighbors = {}
	for(const neighbor of data) {
		// The reference person is also being counted here. Need to remove?
		let id = neighbor["personid"]
		
		Object.keys(neighbor).forEach(key => {
			
			if(skipAttributes.includes(key)) return
			if(isNaN(closest_neighbors[id]))
				closest_neighbors[id] = 0
			// Incrementing count for same conditions as @person in each @neighbor
			if(personAttributes[key]=="True")
				closest_neighbors[id] += (neighbor[key] == personAttributes[key])
		})
	}

	// Sorting in descending order and mapping to a rank
	closest_neighbors = Array.from(Object.entries(closest_neighbors).map(e=>e))
	closest_neighbors.sort( (a,b) => (a[1] < b[1])?1:-1 )
	var rank = new Map()
	var n = 0
	var max_rank = 0
	for(const i of closest_neighbors) { 

		// Counting only the ones who have  attributes in common
		if(i[1] > 0) n++
		max_rank = (max_rank < i[1])?i[1]:max_rank

		rank.set(i[0], i[1]) 
	}
	
	// Smallest square matrix possible to contain n elements such as n[i] != 0
	n = Math.floor(Math.sqrt(n))


	// ---------- DRAWING THE GRAPH ---------- //
	var labels = [...Array(13).keys()]
	var x = d3.scaleBand()
		.range([0, width])
		.domain(labels)
		.padding(0.01)
	svg.append("g")
		.attr("transform", "translate(0," + height + ")")
		.call(d3.axisBottom(x))
	var y = d3.scaleBand()
		.range([0, height])
		.domain(labels)
		.padding(0.01)
	svg.append("g")
		.call(d3.axisLeft(y))

	var color = d3.scaleLinear()
		.range(["white", "#69b3a2"])
		.domain([0.0, 1.0])
	
	svg.selectAll()
		.data(data)
		.enter()
		.append("rect")
			.attr("x", (d,i) => x(i/13>>0))
			.attr("y", (d,i) => y(i%13>>0))
			.attr("width", x.bandwidth)
			.attr("height", y.bandwidth)
			.style("fill", d => color(rank.get(d.personid)/max_rank))

	// Removing 0 ranked elements
	//svg.selectAll("rect").filter((d,i)=> (rank.get(d.personid)==0)).remove();
	

});
